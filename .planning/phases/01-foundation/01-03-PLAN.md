---
phase: 01-foundation
plan: 03
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - src/lib/supabase.ts
  - src/lib/queryClient.ts
  - src/stores/uiStore.ts
  - src/main.tsx
  - src/App.tsx
  - src/types/database.ts
autonomous: true

must_haves:
  truths:
    - "Supabase client connects without errors"
    - "TanStack Query provider wraps application"
    - "Zustand store persists UI state"
    - "Missing environment variables throw clear error messages"
  artifacts:
    - path: "src/lib/supabase.ts"
      provides: "Supabase client singleton"
      exports: ["supabase"]
      min_lines: 10
    - path: "src/lib/queryClient.ts"
      provides: "TanStack Query client configuration"
      exports: ["queryClient"]
      min_lines: 10
    - path: "src/stores/uiStore.ts"
      provides: "Zustand UI state store"
      exports: ["useUIStore"]
      min_lines: 15
    - path: "src/types/database.ts"
      provides: "TypeScript types for database tables"
      contains: "Transaction"
  key_links:
    - from: "src/main.tsx"
      to: "src/lib/queryClient.ts"
      via: "QueryClientProvider"
      pattern: "QueryClientProvider"
    - from: "src/lib/supabase.ts"
      to: "import.meta.env"
      via: "environment variables"
      pattern: "VITE_SUPABASE"
---

<objective>
Set up Supabase client, TanStack Query provider, and Zustand store with TypeScript types.

Purpose: Establish the state management and backend connection infrastructure for the application.
Output: Working Supabase connection with query caching and UI state management ready for feature development.
</objective>

<execution_context>
@/Users/yedidya/.claude/get-shit-done/workflows/execute-plan.md
@/Users/yedidya/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-foundation/01-RESEARCH.md
@.planning/phases/01-foundation/01-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Supabase client and TypeScript types</name>
  <files>
    src/lib/supabase.ts
    src/types/database.ts
  </files>
  <action>
Create src/lib/supabase.ts with singleton pattern and validation:
```typescript
import { createClient } from '@supabase/supabase-js'
import type { Database } from '@/types/database'

const supabaseUrl = import.meta.env.VITE_SUPABASE_URL
const supabaseAnonKey = import.meta.env.VITE_SUPABASE_ANON_KEY

if (!supabaseUrl) {
  throw new Error('VITE_SUPABASE_URL is required. Check your .env.local file.')
}
if (!supabaseAnonKey) {
  throw new Error('VITE_SUPABASE_ANON_KEY is required. Check your .env.local file.')
}

export const supabase = createClient<Database>(supabaseUrl, supabaseAnonKey)
```

Create src/types/database.ts with TypeScript types matching the database schema:
```typescript
export type Json =
  | string
  | number
  | boolean
  | null
  | { [key: string]: Json | undefined }
  | Json[]

export interface Database {
  public: {
    Tables: {
      user_settings: {
        Row: {
          id: string
          user_id: string
          matching_trigger: string
          auto_approval_threshold: number
          created_at: string
          updated_at: string
        }
        Insert: {
          id?: string
          user_id: string
          matching_trigger?: string
          auto_approval_threshold?: number
          created_at?: string
          updated_at?: string
        }
        Update: {
          id?: string
          user_id?: string
          matching_trigger?: string
          auto_approval_threshold?: number
          created_at?: string
          updated_at?: string
        }
      }
      files: {
        Row: {
          id: string
          user_id: string
          storage_path: string
          file_type: string
          original_name: string
          status: string
          extracted_data: Json | null
          error_message: string | null
          created_at: string
          processed_at: string | null
        }
        Insert: {
          id?: string
          user_id: string
          storage_path: string
          file_type: string
          original_name: string
          status?: string
          extracted_data?: Json | null
          error_message?: string | null
          created_at?: string
          processed_at?: string | null
        }
        Update: {
          id?: string
          user_id?: string
          storage_path?: string
          file_type?: string
          original_name?: string
          status?: string
          extracted_data?: Json | null
          error_message?: string | null
          created_at?: string
          processed_at?: string | null
        }
      }
      transactions: {
        Row: {
          id: string
          user_id: string
          date: string
          value_date: string | null
          description: string
          reference: string | null
          amount_agorot: number
          balance_agorot: number | null
          is_credit: boolean
          channel: string | null
          source_file_id: string | null
          hash: string | null
          created_at: string
        }
        Insert: {
          id?: string
          user_id: string
          date: string
          value_date?: string | null
          description: string
          reference?: string | null
          amount_agorot: number
          balance_agorot?: number | null
          is_credit?: boolean
          channel?: string | null
          source_file_id?: string | null
          hash?: string | null
          created_at?: string
        }
        Update: {
          id?: string
          user_id?: string
          date?: string
          value_date?: string | null
          description?: string
          reference?: string | null
          amount_agorot?: number
          balance_agorot?: number | null
          is_credit?: boolean
          channel?: string | null
          source_file_id?: string | null
          hash?: string | null
          created_at?: string
        }
      }
      invoices: {
        Row: {
          id: string
          user_id: string
          file_id: string | null
          vendor_name: string | null
          invoice_number: string | null
          invoice_date: string | null
          due_date: string | null
          total_amount_agorot: number | null
          vat_amount_agorot: number | null
          currency: string
          confidence_score: number | null
          status: string
          created_at: string
        }
        Insert: {
          id?: string
          user_id: string
          file_id?: string | null
          vendor_name?: string | null
          invoice_number?: string | null
          invoice_date?: string | null
          due_date?: string | null
          total_amount_agorot?: number | null
          vat_amount_agorot?: number | null
          currency?: string
          confidence_score?: number | null
          status?: string
          created_at?: string
        }
        Update: {
          id?: string
          user_id?: string
          file_id?: string | null
          vendor_name?: string | null
          invoice_number?: string | null
          invoice_date?: string | null
          due_date?: string | null
          total_amount_agorot?: number | null
          vat_amount_agorot?: number | null
          currency?: string
          confidence_score?: number | null
          status?: string
          created_at?: string
        }
      }
      invoice_rows: {
        Row: {
          id: string
          invoice_id: string
          description: string | null
          quantity: number | null
          unit_price_agorot: number | null
          total_agorot: number | null
          created_at: string
        }
        Insert: {
          id?: string
          invoice_id: string
          description?: string | null
          quantity?: number | null
          unit_price_agorot?: number | null
          total_agorot?: number | null
          created_at?: string
        }
        Update: {
          id?: string
          invoice_id?: string
          description?: string | null
          quantity?: number | null
          unit_price_agorot?: number | null
          total_agorot?: number | null
          created_at?: string
        }
      }
      credit_cards: {
        Row: {
          id: string
          user_id: string
          card_last_four: string
          card_name: string | null
          created_at: string
        }
        Insert: {
          id?: string
          user_id: string
          card_last_four: string
          card_name?: string | null
          created_at?: string
        }
        Update: {
          id?: string
          user_id?: string
          card_last_four?: string
          card_name?: string | null
          created_at?: string
        }
      }
    }
  }
}

// Convenience types
export type UserSettings = Database['public']['Tables']['user_settings']['Row']
export type File = Database['public']['Tables']['files']['Row']
export type Transaction = Database['public']['Tables']['transactions']['Row']
export type Invoice = Database['public']['Tables']['invoices']['Row']
export type InvoiceRow = Database['public']['Tables']['invoice_rows']['Row']
export type CreditCard = Database['public']['Tables']['credit_cards']['Row']

// Insert types
export type UserSettingsInsert = Database['public']['Tables']['user_settings']['Insert']
export type FileInsert = Database['public']['Tables']['files']['Insert']
export type TransactionInsert = Database['public']['Tables']['transactions']['Insert']
export type InvoiceInsert = Database['public']['Tables']['invoices']['Insert']
export type InvoiceRowInsert = Database['public']['Tables']['invoice_rows']['Insert']
export type CreditCardInsert = Database['public']['Tables']['credit_cards']['Insert']
```
  </action>
  <verify>
Run `npx tsc --noEmit` - should have no type errors in the new files.
  </verify>
  <done>
Supabase client created with typed database schema, environment variable validation in place.
  </done>
</task>

<task type="auto">
  <name>Task 2: Set up TanStack Query and Zustand</name>
  <files>
    src/lib/queryClient.ts
    src/stores/uiStore.ts
    src/main.tsx
    src/App.tsx
  </files>
  <action>
Create src/lib/queryClient.ts:
```typescript
import { QueryClient } from '@tanstack/react-query'

export const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      staleTime: 30_000, // 30 seconds
      gcTime: 5 * 60 * 1000, // 5 minutes
      retry: 1,
      refetchOnWindowFocus: false,
    },
  },
})
```

Create src/stores/uiStore.ts for UI-only state:
```typescript
import { create } from 'zustand'
import { persist } from 'zustand/middleware'

interface UIState {
  sidebarCollapsed: boolean
  toggleSidebar: () => void
  theme: 'dark' | 'light'
  setTheme: (theme: 'dark' | 'light') => void
}

export const useUIStore = create<UIState>()(
  persist(
    (set) => ({
      sidebarCollapsed: false,
      toggleSidebar: () => set((state) => ({ sidebarCollapsed: !state.sidebarCollapsed })),
      theme: 'dark',
      setTheme: (theme) => set({ theme }),
    }),
    {
      name: 'vat-manager-ui',
    }
  )
)
```

Update src/main.tsx to wrap app with QueryClientProvider:
```typescript
import { StrictMode } from 'react'
import { createRoot } from 'react-dom/client'
import { QueryClientProvider } from '@tanstack/react-query'
import { queryClient } from './lib/queryClient'
import App from './App'
import './styles/globals.css'

createRoot(document.getElementById('root')!).render(
  <StrictMode>
    <QueryClientProvider client={queryClient}>
      <App />
    </QueryClientProvider>
  </StrictMode>,
)
```

Update src/App.tsx to verify Supabase connection:
```typescript
import { useEffect, useState } from 'react'
import { supabase } from '@/lib/supabase'
import { useUIStore } from '@/stores/uiStore'

function App() {
  const [connectionStatus, setConnectionStatus] = useState<'checking' | 'connected' | 'error'>('checking')
  const { theme, sidebarCollapsed, toggleSidebar } = useUIStore()

  useEffect(() => {
    const checkConnection = async () => {
      try {
        const { error } = await supabase.from('user_settings').select('count').limit(1)
        if (error) throw error
        setConnectionStatus('connected')
      } catch {
        setConnectionStatus('error')
      }
    }
    checkConnection()
  }, [])

  return (
    <div className={`min-h-screen bg-background text-text ${theme}`}>
      <header className="p-4 border-b border-surface">
        <div className="flex items-center justify-between">
          <h1 className="text-2xl font-bold text-primary">VAT Declaration Manager</h1>
          <div className="flex items-center gap-4">
            <span className={`text-sm ${
              connectionStatus === 'connected' ? 'text-primary' :
              connectionStatus === 'error' ? 'text-red-500' : 'text-text-muted'
            }`}>
              Supabase: {connectionStatus}
            </span>
            <button
              onClick={toggleSidebar}
              className="px-3 py-1 text-sm bg-surface rounded hover:bg-primary/10"
            >
              {sidebarCollapsed ? 'Expand' : 'Collapse'} Sidebar
            </button>
          </div>
        </div>
      </header>
      <main className="p-4">
        <p className="text-text-muted">
          Foundation complete. Ready for Phase 2: Authentication.
        </p>
      </main>
    </div>
  )
}

export default App
```
  </action>
  <verify>
1. Run `npm run dev` - app starts without errors
2. Open browser - should see "Supabase: connected" (or "checking" then "connected")
3. Click sidebar toggle button - verify UI state persists on page refresh
4. Run `npm run build` - production build succeeds
  </verify>
  <done>
TanStack Query configured with caching defaults, Zustand store with persistence, Supabase connection verified in UI.
  </done>
</task>

</tasks>

<verification>
1. `npm run dev` starts without errors
2. Browser shows "Supabase: connected" status
3. Sidebar toggle state persists across page refresh (check localStorage for 'vat-manager-ui')
4. `npm run build` succeeds
5. `npx tsc --noEmit` has no type errors
</verification>

<success_criteria>
- Supabase client connects to database without errors
- TanStack Query provider wraps application
- Zustand store persists UI state to localStorage
- TypeScript types match database schema
- Production build succeeds
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation/01-03-SUMMARY.md`
</output>
