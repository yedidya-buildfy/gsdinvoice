---
phase: 02-authentication
plan: 02
type: execute
wave: 2
depends_on: ["02-01"]
files_modified:
  - src/components/auth/ProtectedRoute.tsx
  - src/pages/LoginPage.tsx
  - src/pages/SignupPage.tsx
  - src/pages/DashboardPage.tsx
  - src/App.tsx
  - src/main.tsx
autonomous: false

must_haves:
  truths:
    - "User can create account with email and password"
    - "User can log in and session persists across browser restarts"
    - "User can log out from any page in the application"
    - "Unauthenticated users are redirected to login"
  artifacts:
    - path: "src/components/auth/ProtectedRoute.tsx"
      provides: "Route guard that redirects unauthenticated users"
      exports: ["ProtectedRoute"]
      min_lines: 15
    - path: "src/pages/LoginPage.tsx"
      provides: "Login page with LoginForm"
      min_lines: 10
    - path: "src/pages/SignupPage.tsx"
      provides: "Signup page with SignupForm"
      min_lines: 10
    - path: "src/pages/DashboardPage.tsx"
      provides: "Protected dashboard with logout button"
      min_lines: 20
    - path: "src/App.tsx"
      provides: "Router configuration with protected routes"
      contains: "BrowserRouter"
  key_links:
    - from: "src/components/auth/ProtectedRoute.tsx"
      to: "src/contexts/AuthContext.tsx"
      via: "useAuth for session check"
      pattern: "useAuth\\(\\)"
    - from: "src/App.tsx"
      to: "src/components/auth/ProtectedRoute.tsx"
      via: "Route element wrapper"
      pattern: "ProtectedRoute"
    - from: "src/pages/DashboardPage.tsx"
      to: "src/contexts/AuthContext.tsx"
      via: "signOut function for logout"
      pattern: "signOut"
    - from: "src/main.tsx"
      to: "src/contexts/AuthContext.tsx"
      via: "AuthProvider wrapper"
      pattern: "AuthProvider"
    - from: "src/pages/LoginPage.tsx"
      to: "src/components/auth/LoginForm.tsx"
      via: "renders LoginForm component"
      pattern: "LoginForm"
    - from: "src/pages/SignupPage.tsx"
      to: "src/components/auth/SignupForm.tsx"
      via: "renders SignupForm component"
      pattern: "SignupForm"
    - from: "src/pages/LoginPage.tsx"
      to: "src/contexts/AuthContext.tsx"
      via: "useAuth for session check to trigger redirect"
      pattern: "useAuth\\(\\)"
---

<objective>
Wire up routing, pages, and protected route guard to complete the authentication flow.

Purpose: Connect all auth components into a working flow where users can sign up, log in, access protected content, and log out. This completes the Phase 2 requirements.

Output: ProtectedRoute component, Login/Signup/Dashboard pages, fully wired App.tsx with React Router, AuthProvider in main.tsx.
</objective>

<execution_context>
@/Users/yedidya/.claude/get-shit-done/workflows/execute-plan.md
@/Users/yedidya/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/02-authentication/02-RESEARCH.md
@.planning/phases/02-authentication/02-01-SUMMARY.md
@src/contexts/AuthContext.tsx
@src/components/auth/LoginForm.tsx
@src/components/auth/SignupForm.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create ProtectedRoute component and page components</name>
  <files>
    - src/components/auth/ProtectedRoute.tsx
    - src/pages/LoginPage.tsx
    - src/pages/SignupPage.tsx
  </files>
  <action>
1. Create `src/pages/` directory if not exists.

2. Create `src/components/auth/ProtectedRoute.tsx`:
   - Import Navigate, Outlet, useLocation from 'react-router'
   - Import useAuth from @/contexts/AuthContext
   - If loading: return centered loading spinner/text
   - If no user: return Navigate to="/login" with state={{ from: location }} replace
   - If user exists: return Outlet (renders nested routes)

3. Create `src/pages/LoginPage.tsx`:
   - Import useNavigate, useLocation from 'react-router'
   - Import useAuth from @/contexts/AuthContext
   - Import LoginForm from @/components/auth/LoginForm
   - Get redirect location from location.state?.from?.pathname || '/'
   - Use useEffect to check if user is already authenticated (from useAuth)
   - If user exists, navigate to the redirect location (handles post-login redirect)
   - This approach uses session state change (from onAuthStateChange) to trigger navigation
   - No prop drilling to form needed - form calls signIn, AuthContext updates, page reacts
   - Center the form on page with min-h-screen flex items-center justify-center
   - Add app title above form

4. Create `src/pages/SignupPage.tsx`:
   - Similar structure to LoginPage
   - Use SignupForm component
   - Use useEffect to check if user becomes authenticated
   - If user exists after signup, redirect to dashboard
   - If no user after successful signup (email confirmation required), show success message or redirect to login
  </action>
  <verify>
- `ls src/pages/` shows LoginPage.tsx, SignupPage.tsx
- `cat src/components/auth/ProtectedRoute.tsx` shows Navigate redirect logic
- `grep -q "useAuth" src/pages/LoginPage.tsx && echo "LoginPage uses useAuth"` - confirms session-based navigation
- `grep -q "useEffect" src/pages/LoginPage.tsx && echo "LoginPage has useEffect"` - confirms reactive navigation
- No TypeScript errors: `npx tsc --noEmit`
  </verify>
  <done>
- ProtectedRoute.tsx redirects unauthenticated users to /login
- LoginPage.tsx renders LoginForm and uses useEffect to navigate when session changes
- SignupPage.tsx renders SignupForm with session-based redirect handling
- Navigation uses session state reactivity (no prop drilling to forms)
  </done>
</task>

<task type="auto">
  <name>Task 2: Create DashboardPage component</name>
  <files>
    - src/pages/DashboardPage.tsx
  </files>
  <action>
1. Create `src/pages/DashboardPage.tsx`:
   - Import useAuth from @/contexts/AuthContext
   - Display user email from user object
   - Add logout button that calls signOut
   - Show "Supabase: connected" status (move from current App.tsx)
   - Use ArrowRightStartOnRectangleIcon from @heroicons/react/24/outline for logout button
   - Style with dark theme compatible Tailwind classes
  </action>
  <verify>
- `cat src/pages/DashboardPage.tsx` shows logout button with signOut call
- `grep -q "signOut" src/pages/DashboardPage.tsx && echo "signOut present"`
- `grep -q "useAuth" src/pages/DashboardPage.tsx && echo "useAuth present"`
- No TypeScript errors: `npx tsc --noEmit`
  </verify>
  <done>
- DashboardPage.tsx shows user info and logout button
- Logout button calls signOut from useAuth
- Displays connection status
  </done>
</task>

<task type="auto">
  <name>Task 3: Wire up App.tsx and main.tsx with routing</name>
  <files>
    - src/App.tsx
    - src/main.tsx
  </files>
  <action>
1. Update `src/main.tsx`:
   - Import AuthProvider from @/contexts/AuthContext
   - Wrap App with AuthProvider (inside QueryClientProvider)
   - Order: StrictMode > QueryClientProvider > AuthProvider > App

2. Rewrite `src/App.tsx` to use React Router:
   - Import BrowserRouter, Routes, Route from 'react-router'
   - Import ProtectedRoute from @/components/auth/ProtectedRoute
   - Import LoginPage, SignupPage, DashboardPage from @/pages/*
   - Structure:
     ```
     <BrowserRouter>
       <Routes>
         <Route path="/login" element={<LoginPage />} />
         <Route path="/signup" element={<SignupPage />} />
         <Route element={<ProtectedRoute />}>
           <Route path="/" element={<DashboardPage />} />
           {/* Future protected routes go here */}
         </Route>
       </Routes>
     </BrowserRouter>
     ```
   - Remove the old connection check and placeholder content (moved to DashboardPage)
   - Keep the dark theme class on root div

3. Ensure the app compiles and runs:
   - `npm run build` should succeed
   - `npm run dev` should start without errors
  </action>
  <verify>
- `grep -q "AuthProvider" src/main.tsx && echo "AuthProvider in main.tsx"`
- `grep -q "BrowserRouter" src/App.tsx && echo "BrowserRouter present"`
- `grep -q "ProtectedRoute" src/App.tsx && echo "ProtectedRoute present"`
- `grep -q 'path="/login"' src/App.tsx && echo "login route present"`
- `grep -q 'path="/signup"' src/App.tsx && echo "signup route present"`
- `npm run build` completes without errors
- `npm run dev` starts successfully (check terminal output)
  </verify>
  <done>
- main.tsx has AuthProvider wrapping the app
- App.tsx has BrowserRouter with /login, /signup as public routes
- Protected routes nested under ProtectedRoute element
- App builds and runs without errors
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>Complete authentication flow with signup, login, logout, and protected routes</what-built>
  <how-to-verify>
1. Start the dev server: `npm run dev`
2. Open http://localhost:5173 in browser
3. Verify redirect: Should automatically redirect to /login (unauthenticated)
4. Test signup flow:
   - Click "Need an account? Sign up" link
   - Enter email and password
   - Submit form
   - Should see success message or redirect (depending on Supabase email confirmation settings)
5. Test login flow:
   - Go to /login
   - Enter credentials
   - Should redirect to dashboard (/)
6. Verify session persistence:
   - Refresh the page
   - Should still be on dashboard (not redirected to login)
7. Test logout:
   - Click logout button on dashboard
   - Should redirect to /login
   - Refresh page - should stay on /login (session cleared)
8. Verify protected route:
   - While logged out, try to access http://localhost:5173/ directly
   - Should redirect to /login
  </how-to-verify>
  <resume-signal>Type "approved" if all checks pass, or describe any issues found</resume-signal>
</task>

</tasks>

<verification>
Phase 2 Authentication is complete when:
1. User can create account with email and password (AUTH-01)
2. User can log in and session persists across browser restarts (AUTH-02)
3. User can log out from any page (AUTH-03)
4. Unauthenticated users redirected to login (AUTH-03)
</verification>

<success_criteria>
- All four roadmap success criteria are met:
  1. User can create account with email and password
  2. User can log in and session persists across browser restarts
  3. User can log out from any page in the application
  4. Unauthenticated users are redirected to login
- No TypeScript or build errors
- Human verification confirms working auth flow
</success_criteria>

<output>
After completion, create `.planning/phases/02-authentication/02-02-SUMMARY.md`
</output>
