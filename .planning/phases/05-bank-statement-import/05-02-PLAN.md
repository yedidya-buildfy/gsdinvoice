---
phase: 05-bank-statement-import
plan: 02
type: execute
wave: 2
depends_on: ["05-01"]
files_modified:
  - src/hooks/useBankStatementUpload.ts
  - src/hooks/useTransactions.ts
  - src/components/bank/BankUploader.tsx
autonomous: true

must_haves:
  truths:
    - "User can select and upload bank statement file"
    - "Parsed transactions are saved to database"
    - "Duplicate transactions are detected by hash"
    - "Transactions can be fetched with loading state"
  artifacts:
    - path: "src/hooks/useBankStatementUpload.ts"
      provides: "Bank statement upload and parsing hook"
      exports: ["useBankStatementUpload"]
    - path: "src/hooks/useTransactions.ts"
      provides: "Transaction fetching with TanStack Query"
      exports: ["useTransactions"]
    - path: "src/components/bank/BankUploader.tsx"
      provides: "Bank file upload UI component"
      exports: ["BankUploader"]
  key_links:
    - from: "src/hooks/useBankStatementUpload.ts"
      to: "src/lib/parsers/bankStatementParser.ts"
      via: "import parseBankStatement"
      pattern: "parseBankStatement"
    - from: "src/hooks/useBankStatementUpload.ts"
      to: "supabase transactions table"
      via: "supabase.from('transactions').insert"
      pattern: "from\\('transactions'\\)"
    - from: "src/components/bank/BankUploader.tsx"
      to: "src/hooks/useBankStatementUpload.ts"
      via: "import useBankStatementUpload"
      pattern: "useBankStatementUpload"
---

<objective>
Create hooks and upload component for bank statement import functionality.

Purpose: Enable users to upload bank statement files, parse them, detect duplicates, and save transactions to the database with proper state management.

Output: useBankStatementUpload hook, useTransactions hook, and BankUploader component ready for integration.
</objective>

<execution_context>
@/Users/yedidya/.claude/get-shit-done/workflows/execute-plan.md
@/Users/yedidya/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/05-bank-statement-import/05-RESEARCH.md
@.planning/phases/05-bank-statement-import/05-01-SUMMARY.md
@src/hooks/useFileUpload.ts
@src/types/database.ts
@src/components/upload/FileUploader.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create useBankStatementUpload hook</name>
  <files>src/hooks/useBankStatementUpload.ts</files>
  <action>
Create a hook that handles bank statement file selection, parsing, and database insertion.

**Interface:**
```typescript
interface UseBankStatementUploadReturn {
  file: File | null;
  status: 'idle' | 'parsing' | 'saving' | 'success' | 'error';
  error: string | null;
  parsedCount: number;
  savedCount: number;
  duplicateCount: number;
  selectFile: (file: File) => void;
  processFile: () => Promise<void>;
  reset: () => void;
}
```

**Implementation:**
1. Import parseBankStatement from '@/lib/parsers'
2. Import supabase from '@/lib/supabase'
3. Import useAuth from '@/contexts/AuthContext'
4. Import TransactionInsert from '@/types/database'

**selectFile:** Store file in state, reset counts and status to idle.

**processFile:**
1. Set status to 'parsing'
2. Call parseBankStatement(file) - wrap in try/catch
3. Set parsedCount to result length
4. Set status to 'saving'
5. For each ParsedTransaction:
   - Generate hash: `btoa(\`${tx.date}|${tx.description.trim()}|${tx.amountAgorot}|${tx.reference || ''}\`)`
   - Check for existing transaction with same hash
   - If duplicate, increment duplicateCount, skip
   - Otherwise, create TransactionInsert:
     ```typescript
     {
       user_id: user.id,
       date: tx.date,
       value_date: tx.valueDate,
       description: tx.description,
       reference: tx.reference,
       amount_agorot: tx.amountAgorot,
       balance_agorot: tx.balanceAgorot,
       is_income: tx.amountAgorot > 0,
       is_credit_card_charge: false,
       source_file_id: null, // No file record for bank imports
       hash: hash,
       match_status: 'unmatched'
     }
     ```
   - Insert to database, increment savedCount
6. Set status to 'success' or 'error' based on outcome

**Duplicate detection:** Query transactions table for matching hash before insert:
```typescript
const { data: existing } = await supabase
  .from('transactions')
  .select('id')
  .eq('hash', hash)
  .eq('user_id', user.id)
  .single();
if (existing) { duplicateCount++; continue; }
```

**Error handling:** Catch errors at each stage, set error message and status to 'error'.
  </action>
  <verify>TypeScript compiles without errors. Import hook in a test file and verify it returns all expected properties.</verify>
  <done>Hook exports useBankStatementUpload, handles file selection, parsing, duplicate detection via hash, and database insertion with proper status tracking</done>
</task>

<task type="auto">
  <name>Task 2: Create useTransactions hook with TanStack Query</name>
  <files>src/hooks/useTransactions.ts</files>
  <action>
Create a hook that fetches transactions from the database using TanStack Query.

**Interface:**
```typescript
interface UseTransactionsReturn {
  transactions: Transaction[];
  isLoading: boolean;
  error: Error | null;
  refetch: () => void;
}
```

**Implementation:**
1. Import useQuery from '@tanstack/react-query'
2. Import supabase from '@/lib/supabase'
3. Import useAuth from '@/contexts/AuthContext'
4. Import Transaction from '@/types/database'

**Query function:**
```typescript
async function fetchTransactions(userId: string): Promise<Transaction[]> {
  const { data, error } = await supabase
    .from('transactions')
    .select('*')
    .eq('user_id', userId)
    .order('date', { ascending: false });

  if (error) throw error;
  return data || [];
}
```

**Hook:**
```typescript
export function useTransactions(): UseTransactionsReturn {
  const { user } = useAuth();

  const { data, isLoading, error, refetch } = useQuery({
    queryKey: ['transactions', user?.id],
    queryFn: () => fetchTransactions(user!.id),
    enabled: !!user,
    staleTime: 30000, // 30s consistent with project pattern
  });

  return {
    transactions: data || [],
    isLoading,
    error: error as Error | null,
    refetch,
  };
}
```
  </action>
  <verify>TypeScript compiles. Hook can be imported and called (will return empty array if no data).</verify>
  <done>Hook exports useTransactions, fetches from database with TanStack Query, handles loading/error states, returns typed Transaction array</done>
</task>

<task type="auto">
  <name>Task 3: Create BankUploader component</name>
  <files>src/components/bank/BankUploader.tsx</files>
  <action>
Create src/components/bank/ directory.

Create a component similar to FileUploader but specific to bank statements.

**Props:**
```typescript
interface BankUploaderProps {
  onUploadComplete?: () => void;
}
```

**Implementation:**
1. Use useBankStatementUpload hook
2. Create drop zone with drag/drop handlers (similar to FileUploader)
3. Accept only xlsx and csv: `accept=".xlsx,.csv"`
4. Show file name after selection
5. Show status indicators:
   - idle: "Select a bank statement file"
   - parsing: "Parsing file..." with spinner (ArrowPathIcon animate-spin)
   - saving: "Saving transactions..." with spinner
   - success: "Imported {savedCount} transactions ({duplicateCount} duplicates skipped)"
   - error: error message in red
6. Process button: calls processFile(), disabled when status is not idle or no file
7. Call onUploadComplete when status becomes 'success'

**UI Structure:**
```tsx
<div className="w-full">
  {/* Drop zone - similar styling to FileUploader */}
  <div
    onClick={handleClick}
    onDragOver={...}
    onDragLeave={...}
    onDrop={...}
    className="border-2 border-dashed rounded-lg p-6 text-center cursor-pointer ..."
  >
    <TableCellsIcon className="w-12 h-12 mx-auto mb-3 text-text-muted" />
    <p>Drag bank statement or click to browse</p>
    <p className="text-sm text-text-muted">XLSX, CSV</p>
    <input ref={inputRef} type="file" accept=".xlsx,.csv" className="hidden" />
  </div>

  {/* File info and status */}
  {file && (
    <div className="mt-4 p-4 bg-surface rounded-lg">
      <p className="font-medium">{file.name}</p>
      {/* Status display */}
    </div>
  )}

  {/* Process button */}
  {file && status === 'idle' && (
    <button onClick={processFile} className="mt-4 w-full bg-primary ...">
      Import Transactions
    </button>
  )}
</div>
```

Import icons from @heroicons/react/24/outline: TableCellsIcon, ArrowPathIcon, CheckCircleIcon, ExclamationCircleIcon.
  </action>
  <verify>Component renders without errors. Drop zone accepts xlsx/csv files. Status changes are visible.</verify>
  <done>BankUploader component renders with drop zone, file selection, status display, process button, calls onUploadComplete on success</done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes without errors
2. useBankStatementUpload hook can be imported and returns expected interface
3. useTransactions hook can be imported and returns transactions array
4. BankUploader component renders and accepts file input
5. All files exist in correct locations
</verification>

<success_criteria>
- [ ] useBankStatementUpload hook handles file selection, parsing, duplicate detection, and DB insert
- [ ] Hash-based duplicate detection prevents re-importing same transactions
- [ ] useTransactions hook fetches from database with TanStack Query
- [ ] BankUploader component has drop zone accepting xlsx/csv
- [ ] Status indicators show parsing, saving, success, error states
- [ ] onUploadComplete callback fires on successful import
- [ ] TypeScript compiles without errors
</success_criteria>

<output>
After completion, create `.planning/phases/05-bank-statement-import/05-02-SUMMARY.md`
</output>
