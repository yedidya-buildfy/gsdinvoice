---
phase: 07-ai-document-extraction
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/lib/extraction/types.ts
  - src/hooks/useDocumentExtraction.ts
  - src/hooks/useInvoices.ts
autonomous: true

must_haves:
  truths:
    - "Extraction types define the expected response from Edge Function"
    - "useExtractDocument mutation invokes the Edge Function with file details"
    - "useExtractDocument invalidates document and invoice queries on success"
    - "useInvoices hook fetches invoices from database with file relationship"
    - "Sequential processing available for batch extraction to avoid rate limits"
  artifacts:
    - path: "src/lib/extraction/types.ts"
      provides: "TypeScript types for extraction request/response"
      exports: ["ExtractionRequest", "ExtractionResult", "InvoiceExtraction"]
    - path: "src/hooks/useDocumentExtraction.ts"
      provides: "TanStack Query mutation hook for extraction"
      exports: ["useExtractDocument", "useExtractMultipleDocuments"]
    - path: "src/hooks/useInvoices.ts"
      provides: "TanStack Query hook for fetching invoices"
      exports: ["useInvoices"]
  key_links:
    - from: "src/hooks/useDocumentExtraction.ts"
      to: "supabase.functions.invoke"
      via: "Edge Function invocation"
      pattern: "functions\\.invoke.*extract-invoice"
    - from: "src/hooks/useInvoices.ts"
      to: "supabase.from('invoices')"
      via: "Database query"
      pattern: "from.*invoices.*select"
---

<objective>
Create the client-side hooks and types for triggering AI extraction and fetching invoice data.

Purpose: Provide React components with a clean API to trigger document extraction and display extracted invoice data. The hooks follow the existing TanStack Query patterns used throughout the codebase.

Output: Type-safe extraction hook and invoice query hook ready for UI integration.
</objective>

<execution_context>
@/Users/yedidya/.claude/get-shit-done/workflows/execute-plan.md
@/Users/yedidya/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-ai-document-extraction/07-RESEARCH.md

# Existing patterns to follow
@src/hooks/useDocuments.ts
@src/hooks/useFileUpload.ts
@src/lib/supabase.ts
@src/types/database.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create extraction types</name>
  <files>src/lib/extraction/types.ts</files>
  <action>
Create a new file at src/lib/extraction/types.ts with:

1. **ExtractionRequest** interface:
   - fileId: string
   - storagePath: string
   - fileType: string (pdf, png, jpg, jpeg)

2. **ExtractionResult** interface (matches Edge Function response):
   - success: boolean
   - invoice_id?: string
   - confidence?: number
   - error?: string

3. **InvoiceExtraction** interface (the extracted data shape):
   - vendor_name: string | null
   - invoice_number: string | null
   - invoice_date: string | null
   - subtotal: number | null
   - vat_amount: number | null
   - total_amount: number | null
   - currency: string
   - confidence: number
   - line_items: Array of { description, quantity, unit_price, total } (all nullable)

4. **ExtractionStatus** type union: "pending" | "processing" | "extracted" | "error"

Export all types for use in hooks and components.
  </action>
  <verify>File exists with all type definitions. TypeScript compiles without errors.</verify>
  <done>types.ts exists with ExtractionRequest, ExtractionResult, InvoiceExtraction, and ExtractionStatus types exported</done>
</task>

<task type="auto">
  <name>Task 2: Create extraction hook</name>
  <files>src/hooks/useDocumentExtraction.ts</files>
  <action>
Create the extraction hook following existing hook patterns (see useFileUpload.ts, useBankStatementUpload.ts):

1. **Imports**:
   - useMutation, useQueryClient from @tanstack/react-query
   - supabase from @/lib/supabase
   - Types from @/lib/extraction/types

2. **useExtractDocument hook**:
   - Returns useMutation with:
     - mutationFn: async (params: ExtractionRequest) => ExtractionResult
     - Implementation:
       a. Call supabase.functions.invoke<ExtractionResult>("extract-invoice", { body: { file_id, storage_path, file_type } })
       b. Check for error, throw if present
       c. Check data.success, throw Error(data.error) if false
       d. Return data
     - onSuccess: Invalidate queries with keys ["documents"] and ["invoices"]

3. **useExtractMultipleDocuments hook**:
   - For batch processing (extract button on multiple selected docs)
   - Uses useMutation wrapping the single extraction
   - mutationFn: async (documents: ExtractionRequest[]) => void
     - Process documents sequentially with for...of loop
     - Add 500ms delay between requests (avoid rate limits)
   - onSettled: Invalidate both query keys

Both hooks should follow error handling patterns from existing hooks.
  </action>
  <verify>
Check that:
- Hook imports and exports are correct
- useMutation pattern matches existing hooks
- Query invalidation uses correct keys
- Error handling throws proper Error objects
  </verify>
  <done>
useDocumentExtraction.ts exists with:
- useExtractDocument mutation hook
- useExtractMultipleDocuments for batch processing
- Proper query invalidation
- Error handling
  </done>
</task>

<task type="auto">
  <name>Task 3: Create invoices query hook</name>
  <files>src/hooks/useInvoices.ts</files>
  <action>
Create a hook to fetch invoices following the useDocuments.ts pattern:

1. **Imports**:
   - useQuery from @tanstack/react-query
   - supabase from @/lib/supabase
   - Invoice type from @/types/database

2. **UseInvoicesOptions interface**:
   - status?: string (filter by invoice status)
   - fileId?: string (filter by source file)

3. **InvoiceWithFile type**:
   - Extends Invoice with optional file relation
   - file?: { original_name: string; storage_path: string } | null

4. **useInvoices hook**:
   - Takes optional options parameter
   - Returns useQuery with:
     - queryKey: ["invoices", status, fileId]
     - queryFn: async function that:
       a. Builds query: supabase.from("invoices").select("*, file:files(original_name, storage_path)")
       b. Adds .eq("status", status) if status provided
       c. Adds .eq("file_id", fileId) if fileId provided
       d. Orders by created_at descending
       e. Throws on error
       f. Returns data as InvoiceWithFile[]
     - staleTime: 30 * 1000 (matches existing pattern)

Export the hook and InvoiceWithFile type.
  </action>
  <verify>
Check that:
- Query follows useDocuments pattern
- File relation is properly typed
- Filters work correctly
- staleTime matches codebase convention
  </verify>
  <done>
useInvoices.ts exists with:
- useInvoices query hook
- InvoiceWithFile type with file relation
- Optional status and fileId filters
- 30s staleTime matching existing hooks
  </done>
</task>

</tasks>

<verification>
1. All three files exist in correct locations
2. Types are consistent between Edge Function response and client types
3. Hooks follow existing TanStack Query patterns
4. Query keys match existing conventions
5. Error handling is consistent with codebase
</verification>

<success_criteria>
- src/lib/extraction/types.ts exports all extraction-related types
- useExtractDocument invokes Edge Function correctly
- useExtractMultipleDocuments handles batch processing with delay
- useInvoices fetches invoices with file relationship
- All hooks follow existing codebase patterns
</success_criteria>

<output>
After completion, create `.planning/phases/07-ai-document-extraction/07-02-SUMMARY.md`
</output>
